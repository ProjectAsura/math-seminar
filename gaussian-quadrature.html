<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>プログラマの為の数学勉強会</title>

    <!-- For reveal.js -->
    <link rel="stylesheet" href="lib/reveal/css/reveal.css">
    <link rel="stylesheet" href="lib/reveal/css/theme/night.css">
    <link rel="stylesheet" href="lib/reveal/lib/css/ir_black.css">

    <!-- For Graphics -->
    <link rel="stylesheet" href="css/graphics.css">

    <style>
      .reveal .chapter-title {
        margin-top: 3em;
      }

      .reveal {
        font-size: 32px;
        line-height: 1.4em;
      }

      .reveal .slides {
        text-align: left;
      }

      .reveal section img {
        border: none;
        background: 0;
        margin-left: 1em;
        margin-right: 1em;
        box-shadow: none;
      }

      .reveal strong {
        color: yellow;
      }

      .reveal sup {
        font-size: 40%;
      }

      .reveal table {
        margin-top: 0.5em;
        margin-bottom: 0.5em;
        border: 2px solid lightblue;
      }

      .reveal pre {
        font-size: 0.7em;
      }

      .reveal pre code {
        max-height: 600px;
      }

      .reveal .note {
        font-size: 50%;
      }

      .reveal .controls div.navigate-up,
      .reveal .controls div.navigate-down {
        display: none;
      }

      .reveal .block {
        border: solid 2px;
        position: relative;
        border-radius: 8px;
        margin-top: 0.8em;
        margin-bottom: 0.8em;
        padding: 1em 0.8em 1em 0.8em;
      }

      .reveal .block:after {
        content: "";
        display: block;
        clear: both;
        height: 1px;
        overflow: hidden;
      }

      .reveal .answer {
        color: #111111;
      }

      .reveal .block h4 {
        position: absolute;
        top: -0.5em;
        margin: 0 auto;
        background: #111111;
        font-weight: bold;
      }

    </style>

    <!-- Setup libraries for RequireJS-->
    <script src="lib/require.js"></script>

    <script>
      requirejs.config({
        baseUrl: "js",
        paths: {
          d3: "../lib/d3/d3.v3.min",
          numeric: "../lib/numeric-1.2.6",
          MathJax: "http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"
        },
        shim: {
          d3: { exports: "d3" },
          numeric: { exports: "numeric" },
          MathJax: { exports: "MathJax" }
        }
      });
    </script>

    <!-- Initialize MathJax -->
    <script type="text/x-mathjax-config">
      require(["MathJax"], function (MathJax){
        MathJax.Hub.Register.StartupHook("AsciiMath Jax Config", function () {
          var AM = MathJax.InputJax.AsciiMath.AM;
          AM.symbols.push(
            {input:"mathbi",tag:"mstyle",atname:"mathvariant",atval:"bold-italic",
             output:"mathbi",tex:null,ttype:AM.TOKEN.UNARY}
          );
        });

        MathJax.Hub.Config({
          showProcessingMessages: false,
          skipStartupTypeset: true,
          tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ["\\[","\\]"] ]
          }
        });
      });
    </script>
    <script>
    </script>

  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section>
        <p>
        この資料は「<a href="http://nineties.github.io/math-seminar/">プログラマの為の数学勉強会</a>」を補うものです。
        </p>
        <p>
        趣旨としては面白いテーマを選んで,numpyやmaximaなどのソフトウェアを使って遊びましょうという事です。
        </p>
        <p>
        勉強会の内容の理解度の確認にも役立つと思います。
        </p>
        </section>

        <section>
        <h2 class="chapter-title"> ガウス求積法 </h2>
        </section>

        <section>
        <p>
        前提知識: <a href="http://nineties.github.io/math-seminar/">第10回まで</a>
        </p>
        <p>
        第6回に紹介したガウス求積法のプログラムを学んだ知識を使って書いてみましょう。
        </p>
        </section>

        <section>
        <p>
        \(n\)次以下の実数係数多項式からなる線型空間\(P_n\)に
        \[ (f,\ g) = \int_{-1}^1 fg\mathrm{d} x \]
        で内積を入れて内積空間とします。
        </p>
        <p>
        この内積について基底
        \[ \{1, x, x^2, x^3, \cdots, x^n\} \]
        にシュミットの直交化法を用いて出来上がった正規直交基底を
        (正規化されたバージョンの)<strong>ルジャンドル多項式</strong>と呼ぶのでした。
        </p>
        <p>
        これを計算するプログラムをmaximaで書いてみましょう。
        標準ライブラリにもありますが,自前で作ってみることにします。
        </p>
        </section>

        <section>
<pre><code class="maxima" style="font-size:80%">/* gaussian-quadrature.mac */
legendre_polynomials(n) := block([u, v, dot, norm],
    /* 材料にする基底を作る */
    u: makelist(x^i, i, 0, n),

    /* 内積とノルムを定義 */
    dot(f, g) := integrate(f*g, x, -1, 1),
    norm(f)   := sqrt(dot(f, f)),

    /* シュミットの直交化法 */
    v: [ u[1]/norm(u[1]) ],     /* １つ目の基底は長さを1にする(正規化する)だけ */
    for i:2 thru n+1 do block([w],

        /* i番目の基底から,既に作ったv[1],...,v[i-1]方向の成分を除去 */
        w: u[i] - sum( dot(u[i], v[j])*v[j], j, 1, i-1 ),

        /* 正規化してvに追加 */
        v: endcons( w/norm(w), v )
    ),

    /* 式は全て展開して返す事にする */
    return(expand(v))
);
</code></pre>
        </section>

        <section>
        <p>
        これで任意の次数までのルジャンドル多項式を求める事が出来るようになりました。
        </p>
<pre><code class="maxima" style="max-height:450px;font-size:80%">(%i1) load("gaussian-quadrature.mac");
(%o1)                       gaussian-quadrature.mac
(%i2) legendre_polynomials(10);
                                      2                       3
          1     sqrt(3) x  3 sqrt(5) x    sqrt(5)  5 sqrt(7) x    3 sqrt(7) x
(%o2) [-------, ---------, ------------ - -------, ------------ - -----------,
       sqrt(2)   sqrt(2)        3/2         3/2         3/2           3/2
                               2           2           2             2
     4       2                      5                3
105 x    45 x     9    63 sqrt(11) x    35 sqrt(11) x    15 sqrt(11) x
------ - ----- + ----, -------------- - -------------- + -------------,
  7/2     5/2     7/2        7/2              5/2             7/2
 2       2       2          2                2               2
              6                 4                 2
231 sqrt(13) x    315 sqrt(13) x    105 sqrt(13) x    5 sqrt(13)
--------------- - --------------- + --------------- - ----------,
      9/2               9/2               9/2             9/2
     2                 2                 2               2
              7                 5        3/2  3
429 sqrt(15) x    693 sqrt(15) x    21 15    x    35 sqrt(15) x
--------------- - --------------- + ----------- - -------------,
      9/2               9/2             9/2            9/2
     2                 2               2              2
               8                  6                  4                 2
6435 sqrt(17) x    3003 sqrt(17) x    3465 sqrt(17) x    315 sqrt(17) x
---------------- - ---------------- + ---------------- - ---------------
      15/2               11/2               13/2               11/2
     2                  2                  2                  2
                                9                  7                  5
   35 sqrt(17)  12155 sqrt(19) x    6435 sqrt(19) x    9009 sqrt(19) x
 + -----------, ----------------- - ---------------- + ----------------
       15/2            15/2               11/2               13/2
      2               2                  2                  2
                  3                                   10                    8
   1155 sqrt(19) x    315 sqrt(19) x  46189 sqrt(21) x     109395 sqrt(21) x
 - ---------------- + --------------, ------------------ - ------------------
         11/2              15/2              17/2                 17/2
        2                 2                 2                    2
          3/2  6         3/2  4         3/2  2       3/2
   2145 21    x    715 21    x    165 21    x    3 21
 + ------------- - ------------ + ------------ - -------]
        15/2           15/2           17/2         17/2
       2              2              2            2
</code></pre>
        </section>

        <!--
        <section>
        <p>
        \(n\)次のルジャンドル多項式を\(\ell_n(x)\)と書くことにします。次は
        基底
        \[ \{1,x,x^2,\cdots,x^n\} \]
        から基底
        \[ \{\ell_0(x),\ell_1(x),\ell_2(x),\cdots,\ell_n(x)\} \]
        への基底変換行列を求めましょう。<p>
        基底変換行列は,新しい基底の各ベクトルの,元の基底での成分表示を列に並べれば作れるのでした。<br>
        具体的には
        \[ \ell_i(x) = a_0 + a_1x + a_2x^2 + \cdots + a_nx^n \]
        と表した時の成分\((a_0,a_1,\cdots,a_n)^T\)を第\(j\)列とする行列になるのでした。
        </p>
        </section>

        <section>
<pre><code class="maxima" style="max-height:450px;font-size:80%">change_of_basis_matrix(ls) := block([n,a],   /* 引数lsにルジャンドル多項式を渡す */
    n: length(ls)-1,

    /* 基底変換行列の第j列はls[j+1]の係数。(maximaは1-originなので注意) */
    /* つまり,第(i,j)成分はls[j+1]のx^iの係数 */
    a[i, j] := coeff(ls[j+1], x, i),

    genmatrix(a, n, n, 0, 0)  /* 行列を作成 */
);
</code></pre>
        </section>

        <section>
        <p>
        これで基底変換行列を求められる様になりました。以後,基底変換行列を\(P\)とします。
        </p>
<pre><code class="maxima" style="max-height:500px;font-size:80%">(%i1) load("gaussian-quadrature.mac");
(%o1)                       gaussian-quadrature.mac
(%i2) ls : legendre_polynomials(3);
                                      2                       3
          1     sqrt(3) x  3 sqrt(5) x    sqrt(5)  5 sqrt(7) x    3 sqrt(7) x
(%o2) [-------, ---------, ------------ - -------, ------------ - -----------]
       sqrt(2)   sqrt(2)        3/2         3/2         3/2           3/2
                               2           2           2             2
(%i3) change_of_basis_matrix(ls);
                 [    1                sqrt(5)              ]
                 [ -------     0     - -------       0      ]
                 [ sqrt(2)               3/2                ]
                 [                      2                   ]
                 [                                          ]
                 [          sqrt(3)               3 sqrt(7) ]
                 [    0     -------      0      - --------- ]
                 [          sqrt(2)                  3/2    ]
                 [                                  2       ]
(%o3)            [                                          ]
                 [                   3 sqrt(5)              ]
                 [    0        0     ---------       0      ]
                 [                      3/2                 ]
                 [                     2                    ]
                 [                                          ]
                 [                               5 sqrt(7)  ]
                 [    0        0         0       ---------  ]
                 [                                  3/2     ]
                 [                                 2        ]
</code></pre>
        </section>
        -->

        <section>
        <p>
        では,ガウス求積法の復習をしましょう。
        </p>
        <p>
        任意の\(n-1\)次以下の多項式\(g(x)\)は
        \[ g(x) = a_0\ell_0(x) + a_1\ell_1(x) + \cdots + a_{n-1}\ell_{n-1}(x) \]
        と書けます。するとこの両辺と\(\ell_{n}(x)\)の内積を取れば,
        \[ \ell_0(x),\ \ell_1(x),\ \cdots,\ \ell_n(x) \]
        は直交系なのですから
        \[ (g(x),\ \ell_n(x)) = 0\]
        つまり
        \[ \int_{-1}^1g(x)\ell_n(x)\mathrm{d}x = 0\]
        が成立します。
        </p>
        </section>

        <section>
        <p>
        従って,任意の\(2n-1\)次以下の多項式\(f(x)\)を\(\ell_n(x)\)で割って
        \[ f(x) = q(x)\ell_n(x) + r(x) \]
        とすれば\(q,r\)は\(n-1\)次以下となるので
        \[ \int_{-1}^1f(x)\mathrm{d} x = \int_{-1}^1r(x)\mathrm{d} x \]
        が厳密に成立します。こうやって被積分関数の次数を下げられる事が,ガウス求積法のポイントなのでした。
        </p>
        </section>
      </div>
    </div>


    <script src="lib/reveal/lib/js/head.min.js"></script>
    <script src="lib/reveal/js/reveal.js"></script>

    <script>
      Reveal.initialize({
        width: 960,
        height: 640,
        controls: true,
        progress: false,
        history: true,
        overview: false,
        touch: true,
        center: false,
        rollingLinks: false,
        transition: "page",
        transitionSpeed: "default",

        // When scale != 1, positions of mouse events will be incorrect.
        minScale: 1.0,
        maxScale: 1.0,

        dependencies: [
					{ src: "lib/reveal/lib/js/classList.js", condition: function() { return !document.body.classList; } },
					{ src: "lib/reveal/plugin/highlight/highlight.js", async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: "lib/reveal/plugin/zoom-js/zoom.js", async: true, condition: function() { return !!document.body.classList; } },
					{ src: "lib/reveal/plugin/notes/notes.js", async: true, condition: function() { return !!document.body.classList; } }
          ]
      });

      // register event listeners
      require(["MathJax"], function (MathJax) {

        // Delay typesetting of slides
        function typeset (idx) {
          for (var i = idx - 2, n = idx + 2; i <= n; i++) {
            var slide = Reveal.getSlide(i);
            if (!slide) continue;
            if (!slide.typeset) {
              MathJax.Hub.Typeset(slide);
              slide.typeset = true;
            }
          }
        }

        function initializeGraphics (idx) {
          for (var i = idx - 2, n = idx + 2; i <= n; i++) {
            var slide = Reveal.getSlide(i);
            if (!slide) continue;
            var graphics = slide.getAttribute("graphics");
            if (graphics && !slide.initialized) {
              slide.initialized = true;
              (function () {
                var p = slide;
                require([graphics], function(g) {
                  if (g.initialize) g.initialize(p);
                });
              })();
            }
          }
        }

        function start (slide) {
          var graphics = slide.getAttribute("graphics");
          if (graphics) {
            require([graphics], function(g) { if (g.start) g.start(slide); });
          }
        }

        function stop (slide) {
          var graphics = slide.getAttribute("graphics");
          if (graphics) {
            require([graphics], function(g) { if (g.stop) g.stop(slide); });
          }
        }

        function simpleEvent (type) {
          var event = document.createEvent("HTMLEvents");
          event.initEvent(type, true, true);
          return event;
        }

        Reveal.addEventListener("slidechanged", function (event) {
          typeset(event.indexh);
          initializeGraphics(event.indexh);
          start(event.currentSlide);
          stop(event.previousSlide);
        });

        Reveal.addEventListener("fragmentshown", function (event) {
          var slide = Reveal.getCurrentSlide();
          var graphics = slide.getAttribute("graphics");
          if (graphics) {
            require([graphics], function(g) { if (g.proceed) g.proceed(slide); });
          }
        });

        typeset(Reveal.getIndices().h);
        initializeGraphics(Reveal.getIndices().h);
        start(Reveal.getCurrentSlide());
      });
    </script>
  </body>
</html>
